Thor Long
Spring 2023
CSE 109 Classroom Notes

_________________

1/30/2023 Grading and compiling on the sunlab, so use it to program as well.

PATH: searches inorder for commands We changed PATH in HW0 to make the current directory something that we search while compiling BASH: 
bourne again shell, language we remote into the sunlab

'man' command: manual pages to read different manuals for code.

'mg -o program program.c': compiles c programs with all the warnings and other stuff you want, creates the executable file as the name you 
	provide rather than a.out


Why C? Weakly-typed: Can read data from memory as any type you like Flexible, puts the decision in the programmer's hand's Staticly-typed: 
	Types are only checked at compile time Structured: Structures used to control the flow of execution Procedural: Series of well 
	structured steps, systematic order of statements, functions, and commands. Lower level: Can directly access structures that are 
	tied to hardware. Minimal: No ops to directly deal with strings, lists, or arrays. No help.

C was created to be simple, flexible, and to trust the programmer. Provides only one way to do each operation. Fast, not necessarily 
portable. C is at the top of benchmark times. C is used in Microsoft Windows, Linux, Mac, and Mobile

'#' octothorpe loads files '#include <stdio.h>' loads header file


2/1/2023 Introducing arguments and pointers

Typical declaration for main is: int main(int argc, char *argv[]){} argc, argv are arguments (arg count arg values respectively) argv is 
	an array of pointers.
The very first entry in argv[] (argv[0]) is a pointer to the name of the program that was executed. ALWAYS

A pointer is an address in memory. Can have a variable that contains the address to something. int x; //x is an integer variable int *xp = 
	&x; //*xp is a pointer to type int whose initial value is equal to the address of x

Segment violation: going to areas in memory that isn't allowed results in that Hard link: Multiple names for the same file.

Has an array of addresses that point to the start of each string. Array of pointers.

Segmentation violation: Program tried to access an area of memory tht isn't allowed to access

Use double quotes to bypass whitespace as automatic displacement.

Do we need a null integer before you access a memory. Fixlengthed data types need null terminator.

'chmod': to change permissions

64 bit addressable machines are 8 bytes.
Not passing the array, pasing out the reference to the cell of the array.

'int *ip = &array[3];' asterisk is a pointer, all addresses are 8 bytes. Doesn't matter what it points to, regardless any address on a 64 bit
	machine is 8 bytes.
'&': ampersand symbol: Looks for the address of something. Ampersand A mpersand. Address. Printing out the address of
		       variable.
'*': pointer: Points to something, used three ways. 1. Denotes a variable as a pointer. 2. If you see it before a
		variable, it says we want to follow the reference to what it's pointing to in memory. 3. Multiplication

2/6/2023
Stdout is where standard output goes to. fprintf lets the programmer dictate where the output is being pushed to.

Can cast parameters to void if you aren't using them to suppress unused parameter warnings

atoi - ascii to integer.
ascii - 8 bit char represented on a table. Must convert ascii to integer, that's what the atoi function does.
	converts ascii characters to integers.

Variables in the main function are different than variables in other functions even if they have the same name.

Can specify that you want variables to be pointers, and will then expect an address, and will require you to follow the
reference. Can use this to modify the values of variables in main from other functions, to get around the aformentioned
note about variables in the main function.

Specify type of pointer therefore able to associate the amount of bytes needed to allocate  to hold each type.
Can step through array individually and traverse via addresses if you KNOW that something is there.

Pointers almost equal arrays

All three of these are equivalent ways to access memory.
ip[3] == *(ip+3) == array[3];

2/8/2023
Registers - Memory, but not accessible memory. Only place where operations can take place. Registers are 64 bits in size. Instructions are stored
in executable files, and need to be able to run from registers.

gdb -tui --args [program] [arg1] [arg2]  - Lets you step through your program one operation at a time. Also what the lab assignment is on friday. -tui means text user interface
	Can add break points 'break line#'
		Breakpoints stop and doesn't execute the line that it breaks at
	Use 'step' or 'next' to go through the program line by line with breakpoints.
	Step lets you go inside that function if loaded with -g
	Use 'print [variable]' to see what the program sees each variable as. Or add &[variable] to see address
	Use 'set' to set a variable to a different value mid-debugging
	$rdi shows whatever the register is at 1st. $rsi is second. Da first. The Second. Not able to access it, it's temporary. 16 fixed point
		registers. Number of other registers for float points. Advancements in chips increase the amount of transistors, therefore increasing
		the registers.
	Pass pointer whenever you want to manipulate the variable.
	Use 'watch [variable]' to get notified about change in variables.

	There's a proficiency test for gdb so learn it. It will be important. So definitely yeah.

Every time you need to go out into memory to find a value it's more inefficient in time, way more clock cycles.
Try to make access from memory go into dram and caches so they are more fast. Performance is gold.

2/13/2023

We can modify variables in the other function by passing in the address & and de referencing the variable * and changing that.
Just like creating ssh key pair you need to upload the key pair in gitlab as well.
(See switch4.c in labs)

'Which' is looking for executables

2/15/2023
Programs in Memory, Dynamic Memory Allocation, and Valgrind

In C you must allocate the memory.
What is the difference between static and dynamic memory allocation

Static is allocated before the program runs
Dynamic is allocated after the program runs
	Running a program and allocate space as new information is coming in
		Saves space

How do we allocate dynamically?

When we execute a program, working with the OS it loads portions of the executable file into memory
and create a virtual memory allocation/representation. 
	Usually around address 0x400000

Every program gets placed in its' own memory space.
When the program starts to execute through main, it has to go and get the bytes from memory that represents the instructions on the microprocessor.
	Must map from virtual to physical memory.

As we're going to call a function, information goes on the stack, either popped or ignored and builds it.
Text is the lowest address in the stack, top of the stack command line arguments is the highest address.

Stack is a data structure and behaves like so. 

C Program memory:
1. Text or code segment (program code, values used to initialize global and static variables)
2. Data segment in 2 parts (Initialized variables themselves, global static, and constant data and uninitialized data)

When program is loaded at execution time, the C runtime environment is created and the values of initialized variables from the code (text) segment are placed into respective actual addresses (in RAM)

Stack is a region of memory used for temporary variables.
	Local variables are automatically created on the stack
	Grows/shrinks as functions push and pop local variables
	Variables are allocated and freed automatically
	Limited in size
	Stack variables only exist while function/block is running
Heap is a large region of memory for all types of variables.
	Programmer eeds to allocate memory on the heap
	Programmer needs to free memory or else memory leaks
	Heap variables are global
	Need to use pointers.

If you're never de-allocating heap space you could eventually run out of memory.
	(Garbage collection)
	Valgrind is a tool that helps show garbage collection

Pro/Con List (Stack+Heap)

Stack:
	Fast access, don't have to explicitly deallocate free variables
	Space managed efficiency by CPU, memory won't become fragmented
	Local variables only
	Limit on stack size (OS dependent)
	Variables cannot be resized
		Could mess up addresses if supported
Heap:
	Variables can be accessed globally
	No limit on memory size (kinda)
	Relatively slower access
	No guaranteed efficient use of space, memory may become fragmented
	Programmer must manage memory (allocate/free variables)
	Variables can be resized
		Just need to go to different place with enough memory, make a deepcopy then 

Contiguous memory addresses are useful for time complexity and keeping pointer arithmetic correct

Memory needed is not know during compile time
Needed when a function returns a poitner to a structure created by the function

'man malloc'
Allocating Memory:
malloc - memory allocation
realloc - reallocation memory
free - free memory
sizeof - construct to return size of any object
calloc - clear (set to 0) memory allocation
#include <stdlib.h>

Prototype function:
	Contains name of function
	List of parameters
	Number/Types
	What the function is to return (else void)

size_t is used to identify the size of something in bytes, so it isn't confined by the amount of bytes allowed to allocate other data types.

malloc returns void because it's just a pointer, and allows you to typecast
We want to typecast so we know how many bytes we're pointing to. 

int *arraypointer = (int*malloc) 100;

If we want to free up memory that we already malloc'd free(*arraypointer);
calloc clear alloc, combines the operations of malloc and sets the space to 0.
When we're done programming something, we need to take responsibility to free that memory.

realloc() changes the size of memory block pointer to ptr to size bytes to a new location
	Unpredictable Performance
sizeof() returns the size of any object referred to.
Different mechanisms associated with the blocks of allocated memory. Through the memory manager, we can access that memory.

Fundamentally the same thing as just declaring allocation.
This dynamic allocation will persist and can be globally accessed, can be resized, can be dynamic, and such.

"Static" allocation of space is straightforward, with variables or arrays declared locally or globally
char myarray[1000];
char *ptr=NULL;
for (ptr=myarray; (ptr-myarray) < 1000; ptr++)
   // do something with each entry of myarray
Dynamic allocation asks the OS for space for the pointer to access
#include <stdlib.h>
char *myarray = NULL;
char *ptr = NULL;
myarray = (char *)malloc(1000);  // 1000 in bytes, can be a variable
for (ptr=myarray; (ptr-myarray) < 1000; ptr++)
   // do something with each entry of myarray

No check for if malloc fails.

(Implementation of malloc and memory allocation functions)
#include <stdio.h>
#include <stdlib.h>

int main() {
   char *str;

   /* Initial memory allocation */
   str = (char *)malloc(15);   /* 15 is # of bytes (works for char) */
   strcpy(str, "Dr.ErleTotally");
   fprintf(stdout, "String = %s,  Address = %u\n", str, str);

   /* Reallocating memory */
   str = (char *)realloc(str, 25);
   strcat(str, "Rocks!");
   fprintf(stdout, "String = %s,  Address = %u\n", str, str);

   free(str);
   return(0);
}

Unsafe functions in C could overrun space and go beyond and courrupting data that wasn't supposed to be changed.

C allows you to go to any pointer beyond what you allocated.

One byte more than the string length if you are copying a string
In general, you want the number of objects times the size of an object
So if we were allocating an array of ints, rather than 1-byte chars:
int *ip = (int *)malloc(1000 * sizeof(int));
sizeof is an operator that determines the size of the data type passed as the parameter
Note that just like an array, it is easy to have a pointer (or array index) exceed the allocated space (and cause problems)

2/20/2023 - Virtual Class

When facing development of a larger program, you need to organize how to manage how to develop in separate files.
Reused or organized so they can be used on other projects: top-down development.

Create 'skeleton' of the entire program and step into each function to see what you need to do.

Top-down development: Simple main function that calls other (initially abstract functions) and see how to implement functions so the whole program can be filed and simple testing can be performed.

Bottom-up development: Identify key low-level needs and building functions to provide the services, while also testing code to exercise functions and verify correctness.

Divide-and-conquer: Especially useful when coding in groups, might just share object files with each other (w/ documentation on how to use it)

Use combination of the three.

Modular approach. Know and test specific functions, and don't have to worry about getting the exact variables and functionality.
	Allows to test smaller functions more robust and can implement functionality.
	Debugging also can narrow down the development bugs in order to diagnose each problem.
If you can see the entire algorithm on one screen, it's better to develop in time. 

Can use combination of compiler options and 'make' command.
	man make !!!

Very good to use multiple source code files, saves time, reduces errors.

Can stop compiler before creating an executable, and that not-ready-to-execute binary file can be linked with similar files to create a larger, fully complete executable file.

Continue to use mg, but can do other stuff.

Compiler options of interest:
	-Wall
	-Wextra (can flag legitimate code)
	-Wwrite-strings
	-g inserts debug information into executable
	-c creates a relocatable object file (not executable)

Compiling is not a single step:
	preprocessing: processes include files, conditional compilation instructions, macros
	compilation: takes output of preprocessor and source code and generates assembler source code
		gcc -s produces .s file
	assembly: takes the assembler source code and produces an assembly listing with offsets stored in an object file
		gcc -c t produce .o file
	linking: takes one or more object files or libraries as input and combines them to produce a single executable file
	Use -save-temps to save all intermediate files


Relocatable object file (.o)
	Contains code and data in a form that can be combined with other relocatable object files to form an executable object file.
	Each .o file is produced from exactly one source (.c) file.

Executable object file (a.out)
	Contains code and data in a form that can be copied directly into memory and then executed

Shared object file (.so)
	Special type of relocatable object file that can be loaded into memory and linked dynamically at load or runtime.
	Dynamic Link Libraries by windows (DLL).

All object files have a standard binary format.
One unified format for .o, a.out, .so:
	ELF binaries (executable and linkable format)

gcc -save-temps "blah.c": Shows the different temp object files

Make utility and Makefiles
	With medium to large projects containing many files it's difficult to
		Type commands to compile all the files correctly each time
		Keep track of which files have been changed
		Keep track of files' dependencies on other files
	The make utility automates this process.

make is utility, makefile or Makefile contents.
target:prerequisite
	recipe	<-- must be preceded by tab

Target is file to be generated, usually an executable or object file, and can simply be named of recipe
Prerequisite is zero or more files used to create the target (dependencies)
Recipe is one or more system commands that create the target or achieve the desired result and can span lines.

Makefiles can compile specific changes something and makes its way through the hierarchy instead of the thing, and can compile the things more efficiently.

Forces the intermediate files to be deleted, and then running 'make clean' goes in the top level ones and removes the executable and all .o files
clean:
	rm -f *.o
	rm -f prog

Good programming practices as to do well on the programming projects:
Organization & Readability
	Code written in a modular fashion
	Variables are given meaningful names
	Consistent indentation used for blocks (besides curly braces who cares bout those)
	Functions should generally not exceed one screen, limited to specific purpose/calculation/allocation
	Use stevens-style wrapper functions to make system calls and embed error checking
	Comments are added to describe logic within a block of code.
	Assignment-specific requirements if any, were followed.

Robustness & Efficiency
	Error checking is done wherever possible
	Checking/handling of short counts is performed
	Check every function for failure codes (especially system calls)
	Keep variables' scopes as small as possible (narrow/limited)
	Initialize all variables especially pointers
	Functions created such that code blocks are not duplicated
	Fixed loop bounds are determined prior to entering loop
	Assignment-specific requirements are followed

Strongly consider top-down approach:
	Develop algorithm first (think)
	Create a simple main function with function calls and very little logic
	Create function shells
	Add logic to the function shells slowly and test as you go allocating
	Test thoroughly as notable changes come allocating
	Push changes to repo after each notable change

Defensive programming:
	Larger the project, the more difficult finding subtle errors becomes
	Code defensively by:
		Checking every funciton for failure codes (esp system calls)
		Keep variables' scopes as small and narrow as possible
		Initialize all variables, especially pointers
		Write testing harnesses for all functions
		Document carefully and describe all assumptions for values passed as parameters to your functions
		Verify parameters are valid before you use them
		Use assert liberally to enforce those assumptions

2/22/2023 - Small slide deck for some reason

Position ourselves to learn ourselves. Taught to teach ourselves, and need to learn from ourselves and our resources.
Type out what we need to do. Think before we code, top-down approach.
Start things earlier, begin processing, and read through multiple times.

"It's not that they don't care, but you're always under a time constraing. Decide what you can and cannot get to."

Using make files to pull in and stuff maybe next.
It's not about the money, it's about the message.

System call
Executing instance of a program.
By default all programs execute in user mode.
In order to interact with file system or other restsricted systems or functionalities, a C program must invoke a system call
	A system call can be devined as a request to the operating system to do something on bejalf of the program.
	During execution of a system call, the mode is changed from user mode to kernel mode (aka system mode)
The kernal is the core of the OS program and has control over everything; which is why all other software has to make requests of the OS/Kernel (like to create new processes and manage i/o)

'sleep n' command pauses command for a certain number of seconds.

Can interact with other systems. Ex. cd /proc 
'getenv' reads the user's environment space. Accessing information regarding the user, so it's not really a system call.

System call examples:
creat( ), open( ), close( ) – managing I/O channels
read( ), write( ) – handling input and output operations
lseek( ) – for random access of files
link( ), unlink( ) – aliasing and removing files
stat( ) – getting file status
access( ), chmod( ), chown( ) – for access control
exec( ), fork( ), wait( ), exit( ) – for process control
getuid( ) – for process ownership
getpid( ) – for process ID
signal( ) , kill( ), alarm( ) – for process control
chdir( ) – for changing working directory
mmap(), shmget(), mprotect(), mlock() – manipulate low level memory attributes
time(), gettimer(), settimer(),settimeofday(), alarm() – time management functions
pipe( ) – for creating inter-process communication 

Mentioned about being 'vertically conservative'
	See your whole function on one screen 
	Apply modular programming techniques
	
Wrap system calls.
	Might get error codes.
	Check return value from calls.

With system calls, you should always check the return values.
Error handling.
Save space by using "stevens-style wrapping"
	Only one line of code for system calls, rather than a bunch of them.
	Create a new function, call it the same as your old system call function, but differentiate with a capital letter.

in wrappers.h:

void *Malloc(size_t, size); //declaration, no definition no description, just declaring that the wrapped function exists.

in wrappers.c:

void *Malloc(size_t size){ //actually have the functionality in here
	void *ptr = NULL; //or 0
	if((ptr = malloc(size)) == NULL){ //can put our check in the line
		//must have an error, error handling goes here
		//Print some message and exit with nonzero return code
		//Unique message strerror(errno) shows the string error for error number.
		fprintf(stderr, "Could not allocate space for %ld bytes - %s", size, strerror(errno));
	}
	//Must be non error condition
	return ptr;
}

For program convention in linux, return 0 if things are right, nonzero if things are incorrect
We can have different reasons on why the program fails, if we return 0 when fails, there's no way to distinguish what error occured.

stdout is the default standard out.
stdin is the same terminal/console that you write the program in.
stderr is the standard error stream, could be something different.

2/27/2023
makefile is control file to identify dependencies and recipies in order to create one or more outputs or targets.

When working with modular files, header or source code incorporations doesn't need to worry about what may have changed and automatically 
	calls appropriate recipies in order to construct the program.

Other tools to do the same compilation, but make is a good intro to "dependency management" in the Linux OS

Access struggle:
	Wouldn't let you use the access command in the .h file.
	Look at return codes, not error if file given. Wants to process but know it isn't an executable.

System calls: functionality that our user process does not have access to directly, interacting with the OS to find that functionality.

Equally valid for code writing for error checking and handling in one file source code. 

Assume nonzero non null pointer, pass that and assume that free works correctly

Incude-guard. Guards against the process including something more than one time.

<sizeof.c>

3/1/2023
Left off allocating space, sizeof.c, and introduced valgrind.

Valgrind: Can check memory leaks.
	Memory leak: allocate memory dynamically and doesn't free it when done using it.
	int *pointer = (int) malloc(1024);
	free(pointer); (no)

Why do we need to free it for our program.
	Consuming finite resource and will eventually run out.
	Eventually will try to allocate memory, malloc fails, and results in the end of the program.

How much space do we have?
Dynamic memory allocation happens on the Heap.

Mapping from virtual memory to physical memory happens...? *probably do more research for this.

Pointer is an address, 64 bit machine, so addresses are 8 bytes, so we expect pointers to be 8 bytes each in the sunlab environment.

"When submitting, compile and test on sunlab"
He's obsessed with linux and vi

Interprocessed communication will be covered later. *Maybe look up before we get to that
PowerShell better than cmd, not better than linux BASH.
	Erle script course.

Can write your own signal handler. Handle different signals. How to write signal handler? (CSE202)
Prefer fprintf because you can write to different things (line 457)

Time limit of mastery of gdb, meet with TA/Grader demonstration, in the next few weeks.

(sizeof.c)
Prototypes need to be before we use it, so the compiler read it already and doesn't get confusedington.
Passed in address (*intptr) dereference, grab value, multiply by 2, add x.
Modular programming. Create header file with all prototypes, then C source code file with definition, then #include ".h" file to call it in program.

C pass by value!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

3/4/2023
(thank you montella)
Here is a short reference of what the various file types mean:

- `.h` - C Header file
- `.c` - C Source
- `.i` - C preprocesor output
- `.s` - Assembly
- `.o` - Object Code
- `.a` - Object Archive

1. The C preprocessor - cpp
2. The C frontend - cc
3. The assembler - as
4. The linker - ld

Can write output to certain files by using '> [filename.ext]' after the call to find output.
ex. hexdump -C main.o > mainHexDump.txt creates a text file of the filled hexdump of the object file main.o

3/8/2023 - 
#include <stdbool.h> booleans in C!

char *envp[] does the same thing as char* path = getenv("PATH");
	Can definitely use this, also without a need to use the split function.

Understand the code (and questions about the assignment) for midterm.
	Understand what you should have had done.

"What's wrong with this code"
Don't have to specify the variable name, just the types.

Be familiar with man pages, prototypes, and steven-style wrappers, return values, error conditions, etc.

Hex arithmetic:
	Computers are base 2 (transistors 0 and 1)
	Base 16, 16 different values for numbers, 4 bit chunks.
		Each character represents 4 binary bits.
		Range from 0-15
		0-9 a  b  c  d  e  f
		0-9 10 11 12 13 14 15
		f-e = 1
		16c0 - 02a0

Indexing and printing things out in lab 4.
Look at lab4 for pointers and array syntax etc. Use lab3 for memory allocation and de allocation.

Next programming assignment
HASH TABLE IMPLEMENTATION IN C??!!??!!
	oh no

Exam format:
	Involve conceptual questions
	Look at the code: 
		What is wrong
		What is return
	Makefiles
	Review HW and Labs (All of em)
	Pencil + Paper
	

3/20/2023 - Files and File I/O

Take notes and stuff. Will go through the exam as needed, 5-10 minute warning and look over a few exam questions.
	Exams are not cumulative
	EXCEPT reinforce questions not done well on midterm, and ask the same question.
	Review second half of the course and the midterm material.

Overview: File types, text v binary, standard I/O functions, buffered I/O

In Linux everything is a file.

Each file has a type, indicating the role
	Regular file (text or binary): Contains arbitrary data
	Directories: Index for a related group of files
	Socket: Communicating with a process on another machine

Other file types beyond our scope:
	Named pipes (FIFOs)
	Symbolic links
	Character and block devices

Text vs Binary 'Regular' Files
	Text file contains textual information in the form of alphabets, digits, and special characters or symbols that are human readable (ASCII)
	Binary file contains a collection of bytes not intended to be human-readable

Small error in text file can be recognized and eliminated
Small error in binary file corrupts the file and is not easy to detect
	Since the data is not human readable it also adds to the security of the content

As a programmer, we need to deal with:
	Handling newlines:
		Newline is the end of the line, line ending, or break.
		Usually a special character which signifies the end of the line.
		Newline character ina a text file is converted into a carriage return-linefeed combination
		and then written to the disk; similarly, when read by a text file the carriage return-linefeed combination is converted into a newline
	Storage of numbers:
		The function fprintf() is used to store numerical data on the disk; one character per byte, and as expected integers occupy 4 bytes.
		567392 occupies 6 bytes in memory text file on disk.
	Representation of EOF (End of File):
		In text mode a special character with ASCII code 26 is inserted at the end of file.
		In binary mode, we don't have any special character signifing EOF, instead track the number of characters present in the directory entry of the file.

ELF - Executable and linkable format
All object files adhere to the ELF.
Most byte by byte basis doesn't mean anything in terms of that.
Compression algorithm can save space, then we can uncompress that to get original functions back.

C standard library (libc.so) contains higher-level standard i/o functions (appendix B of K&R)
Ex:
	Opening and closing files (fopen and fclose)
	Reading and writing bytes (fread and fwrite)
	Reading and writing text lines (fgets/getline and fputs)
	Formatted reading and writing (fscanf and fprintf)

Wants to work more with files.

3 files open during every executable file.
	stdin (descriptor 0), stdout (descriptor 1), stderr (descriptor 2) (no need to add (stored in <stdio.h>, extern FILE *stdin;). Standard input, standard output, standard error (respectively))
	Can use fprintf to write to files. Need FULL FILE NAME. Need to open first, then can write.
		Either with handle name or file descriptor, can write to files.
		Descriptor value goes 0,1,2 for the three open standard writing, and +1 per new file that is opened.
	File extention means nothing to the OS in Linux, unlike windows mapping applications to different file types.

File Descriptor:
	Non negative integer which is an index in the kernel on opened files.
	Contained in the kernel file table or file descriptor table
	0 = stdin, 1 = stdout, 2 = stderr

File Pointer:
	Pointer to a C structure
		Struct is a way of aggregating multiple data objects. Simmilar to objects, but without interface with data in the methods.
	Identifies a file, wraps the file descriptor, provides buffering functionality, EOF detection, and all other functionality needed for I/O
	More widely used than file descriptor

Can convert file pointer to file descriptor:
	int fd = fileno(FILE *stream); // in <stdio.h>

Convert file descriptor to file pointer:
	FILE *fp = fdopen(fd, "w"); // in <stdio.h>

Working with Files:
	open, read, write, close, lseek (Unix I/O functions)
	fopen, fread, fwrite, fclose, fseek  (C standard function; buffered)
	fgetc, fputc
	fgets, fputs   note: getline() uses fgets
	fscanf, fprintf
	Never use gets()! (No check on how many bytes you get from that file. Will read all bytes. If user never enters end, it will override bytes in your memory. Worst case scenario, will be able to run code and you will have a bad time)


	http://web.cs.swarthmore.edu/~newhall/unixhelp/C_files.html

Any file in the FILE system have authority to access. Can try to open anything, and need to work with the operating system.
	System call, OS will try, and if returns nonzero, then there is a problem.

Accessing using file pointer, uses the prefix f (like fopen).


read v fread

open, read, write, close:
	Syscalls
	Not formated IO, non-formatted byte statements 
	Do not use UNIX buffer cache
	Generally used for network programming and accessing character devices (keyboards etc)

fopen, fread, fgetc, fwrite, fputc, fclose:
	Functions of standard IO
	Use an internal buffer
	Formatted IO (with %) for some of them
	Always use UNIX buffer cache
	Generally used for general-purpose programming and accessing block devices (harddrives)

Times where we WANT low level control and no buffer going on.

Buffered I/O: Motivation
	Applications often read/write one character at a time
	getc, putc, ungetc
	gets, fgets
		Read line of text one character at a time, stopping at newline
	Implementing as Unix I/O calls expensive
	read and write require Unix kernel calls
		> 10,000 clock cycles
	Solution: Buffered read (fread)
		Uses Unix read to grab block of bytes and place into a buffer
		User input functions take one byte at a time from buffer
	Refill buffer when empty

Standard I/O functions use buffered I/O
	Graphic on L7 slide 12
Buffer flushed to output fd on "\n", call to fflush or exit, or return from main.

Sometimes see segment fault, and didn't get the thing to be flushed to standard out, so never saw it. (gdb -tui executable) (saw before)
	Can force flushing by using the newline character, or calling fflush to flush the buffer, or direct output to stderr since it doesn't have the same buffering that stdout has.

Rather than waiting for complete executable statements in their entirety, write to the buffer and then continue. Flush (taken care of by OS) to keep executing at a good time.

Performing what the user is requesing is the most important thing.
Performance is the second most important thing.
	Both drive companies to make more money.

Why not create a variable and set it rather than #defint BUFFSIZE?
	We're trying to examine the code itself, and having something change each time within the main method, means there is no interference from that line of code in the performance of the program.

Larger = performance time is decreasing, CPU time is dropping.

Exam:
Why do we need to specify the data type when we declare a pointer in C?
	The data type of the pointer is needed so accesses to memory through pointer will read the appropriate amount of bytes, and all have different needs in terms of bytes.

Refer to code and respond to prompts:
Write prototype:
	char func(char*);
Is the argument to func pass by value or pass by reference?
	Pass by value, as C is a pass-by-value language. The address of the 4th character is passed to func.
If func returns a value of 0, what is the output of the printf statement?
	the exam

3/22/2023 - File Continue Slide 13

Recap:
	Files, 6 differnt types. Focusing on regular files and directories. (Text and Binary files)
	All 1s and 0s, but text files are interpreted (8 bits/1 byte) and maps them using ASCII and presents us with their respective representations.
	Binary files could map to human readable stuff, but is a proprietary format that isn't intended to be human-readable.
	Binary has no newline character, no line by line file.
	Binary files has no EOF character. When using pointer of type file, it handles that for us. No being reliant on EOF character.
	Buffer in terms of reading and writing. Have 
	Lab Friday

PROGRAMING IN getLine.c (notes on the program in there)
man getLine
C is pass by value. So, if we want to change particular variable values, we need to pass the address of the variable (already known). Unless we pass address, we can't change the actual value.
getLine may change address of the pointer.
ssize_t is (signed size meaning possible negative) meant to hold integer value representing the size of some object. This is sort of generic, since some systems will vary with different variables on different machines.

Pointers are addresses.

mail [email address]
sends an email?????

PONTER TO POINTER
Allocating a new location on the heap to adjust the allocated length from a smaller to larger space in memory.
Can see where the string starts and we have it at the end, and see that the newline character is stored with the buffer.
Length picked a reasonable sized buffer for what the command line thinks that it will need to allocate.
Notice that with the length, we see that the size of length doesn't decrease when reading subsequent smaller sizes of strings by the user.


FILE *fopen(char *filename, char *mode)
	Opens the file whose name is the string pointed to by filename and associates a stream with it
	r  - open for reading
	w  - open for writing (file need not exist)
	a  - open for appending (file need not exist)
	r+ - open for reading and writing, start at beginning
	w+ - open for reading and writing (overwrite file)
	a+ - open for reading and writing (append if file exists)
Example 
FILE *fp = NULL;
if ((fp=fopen("/home/merle/dork.txt", "r")) != NULL)...

int fclose(FILE *stream)
	flushes  the stream pointed to by fp (writing any buffered output data) and closes the underlying file descriptor
	0 if successful, EOF (macro, usually = -1) if failure
Example
if (fclose(fp)) fprintf(stderr, "error closing file\n”);

3/27/2023 - 
Shortcount -- Read in 1024 bytes at a time. Might not get that all at the same time. Possible to actually get less than you wanted to.

In some situations, read/recv and write/send transfer fewer bytes than the application requests
These short counts do not indicate an error
They occur for a number of reasons:
Encountering EOF on reads - suppose we are ready to read from a file that contains only 20 more bytes from the current file position, and we are reading the file in 50-byte chunks… the next
read will return a short count of 20, and the read after that will signal EOF by returning a short count of zero
Reading text lines from a terminal - if the open file is associated with a terminal (i.e., a keyboard and display), then each read function will transfer one text line at a time, returning a short count equal to the size of the text line
Reading and writing network sockets - if the open file corresponds to a network socket, then internal buffering constraints and long network delays can cause read and write to return short counts.

In practice, you will never encounter short counts when
reading from disk files except on EOF
writing to disk files except if disk is full
However, if you want to build robust (reliable) network applications such as Web servers, then you must deal with short counts by repeatedly calling read/recv and write/send until all requested bytes have been transferred (or time out)
So… your programs should check for short counts and handle them

https://stackoverflow.com/questions/1386142/handling-partial-return-from-recv-tcp-in-c

Lab5 Discussion:
sscanf and getline

Wants to be working on it, not supposted to be stressin out
Pass an argument given a parameter.
Stevens style wrapper and manpages should be second nature.
	These stevens style wrapping is using the man pages to check the errors so we can use the functions with error handling
	Need to understand what errors could happen in order to get it to work. 
Good practice to use same variable names as the man page. Use names that reflect what variables hold. 

Should have looked up the syntax for the code in runFilterFile.bash
for example 2>|stderr.txt takes output for opened file 2 and put it to stderr.txt

.bash $? means look at return code from last command. = 0 then successful because it successful.

Concepts are same throughout all coding languages, but syntax is different.
	Bash seems fun.
makefiles create top down, if no exist, follow the thing.

semicolon is delimter for linux command line bash, you can separate different commands and write them one after another
use fgets not gets so we don't get blown up.
In theory we don't need clean in makefile since the time stamps are already 


Bits and Binary:
Transistor: Designed 1947 Allentown PA Bell labs. 2 state device. 0 Voltage or 1 volt.

Each bit is 0 or 1.
By encodding and interpreting sets of bits in various ways, computers determine what to do (instructions) and represent and manipulate numbers, sets, strings, etc.
Why bits? Electronic ImplementationEasy to store with bistable elements
Reliably transmitted on noisy and inaccurate wires.

Logic 0 (ground/zero volts)
Logic 1(1 volt)
Not precise in volts, but you get the jist.

Fractional values imprecise.
It makes sense to do arithmetic in base 10 now since the plethora of stuff.
Intel IBM came out with chips that take floating point arithmetic in base 2 and base 10.

Byte = 8 bits
Binary 000000002 to 111111112
Decimal: 010 to 25510
Hexadecimal 0016 to FF16
	Base 16 number representation
	Use characters ‘0’ to ‘9’ and ‘A’ to ‘F’
	Write FA1D37B16 in C as
	0xFA1D37B
	0xfa1d37b 
In binary it's no different, just the places. 

Octal is in regards to premission representations (ls -al)

George Boole (19th Century)
Boolean logic, boolean algebra.
True = 1 False = 0.

Boolean algebra
AND& OR| NOT~ EXCLUSIVE-OR^

Operate on bit vectors
Operations applied bitwise (140 type beat)

 01101001  
&01010101
_________
 01000001


 01101001
|01010101
_________
 01111101


 01101001
^01010101
_________
 00111100


~01010101
_________
 10101010

When we perform logical and arithmetic operations, condition bits are set in a register to indicate
different parameters and bits that mean different things. 

Operations &,  |,  ~,  ^ Available in C
Apply to any “integral” data type
	long, int, short, char, unsigned
View arguments as bit vectors
Arguments applied bit-wise

Examples (Char data type)
~0x41 ➙ 0xBE
~010000012 ➙ 101111102
~0x00 ➙ 0xFF
~000000002 ➙ 111111112
0x69 & 0x55 ➙ 0x41
011010012 & 010101012 ➙ 010000012
0x69 | 0x55 ➙ 0x7D
011010012 | 010101012 ➙ 011111012

Logical operations in C that relate to these bitwise operations (kinda).

Contrast to Logical Operators
	&&, ||, !    ⇐ logical AND, logical OR, logical NOT
		View 0 as “False”
		Anything nonzero as “True”
		Always return 0 or 1
		Early termination (for && and ||)  ⇐ Good to know!
Examples (char data type)
	!0x41  ➙  0x00 //any one or more bits is one, generate 0
	!0x00  ➙  0x01
	!!0x41  ➙  0x01
	0x69 && 0x55  ➙  0x01
	0x69 || 0x55  ➙  0x01
	p && *p 	(avoids null pointer access)

Shift operations
	We can shift left by some number of bits, and it will put 0s in any bit locations that have been vacated.
	Can do multiply by 2 by just left shifting.
	Can do division by 2 by just right shifting.

	Left Shift: 	x << y
		Shift bit-vector x left y positions
		Throw away extra bits on left
		Fill with 0’s on right
	Right Shift: 	x >> y
		Shift bit-vector x right y positions
		Throw away extra bits on right
		Logical shift
		Fill with 0’s on left
		Arithmetic shift
		Replicate most significant bit on left
	Undefined Behavior	
		Shift amount < 0 or ≥ word si

Shifting right logically or arithmetically.
