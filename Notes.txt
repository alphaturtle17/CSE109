1/30/2023 Grading and compiling on the sunlab, so use it to program as well.

PATH: searches inorder for commands We changed PATH in HW0 to make the current directory something that we search while compiling BASH: 
bourne again shell, language we remote into the sunlab

'man' command: manual pages to read different manuals for code.

'mg -o program program.c': compiles c programs with all the warnings and other stuff you want, creates the executable file as the name you 
	provide rather than a.out


Why C? Weakly-typed: Can read data from memory as any type you like Flexible, puts the decision in the programmer's hand's Staticly-typed: 
	Types are only checked at compile time Structured: Structures used to control the flow of execution Procedural: Series of well 
	structured steps, systematic order of statements, functions, and commands. Lower level: Can directly access structures that are 
	tied to hardware. Minimal: No ops to directly deal with strings, lists, or arrays. No help.

C was created to be simple, flexible, and to trust the programmer. Provides only one way to do each operation. Fast, not necessarily 
portable. C is at the top of benchmark times. C is used in Microsoft Windows, Linux, Mac, and Mobile

'#' octothorpe loads files '#include <stdio.h>' loads header file


2/1/2023 Introducing arguments and pointers

Typical declaration for main is: int main(int argc, char *argv[]){} argc, argv are arguments (arg count arg values respectively) argv is 
	an array of pointers.
The very first entry in argv[] (argv[0]) is a pointer to the name of the program that was executed. ALWAYS

A pointer is an address in memory. Can have a variable that contains the address to something. int x; //x is an integer variable int *xp = 
	&x; //*xp is a pointer to type int whose initial value is equal to the address of x

Segment violation: going to areas in memory that isn't allowed results in that Hard link: Multiple names for the same file.

Has an array of addresses that point to the start of each string. Array of pointers.

Segmentation violation: Program tried to access an area of memory tht isn't allowed to access

Use double quotes to bypass whitespace as automatic displacement.

Do we need a null integer before you access a memory. Fixlengthed data types need null terminator.

'chmod': to change permissions

64 bit addressable machines are 8 bytes.
Not passing the array, pasing out the reference to the cell of the array.

'int *ip = &array[3];' asterisk is a pointer, all addresses are 8 bytes. Doesn't matter what it points to, regardless any address on a 64 bit
	machine is 8 bytes.
'&': ampersand symbol: Looks for the address of something. Ampersand A mpersand. Address. Printing out the address of
		       variable.
'*': pointer: Points to something, used three ways. 1. Denotes a variable as a pointer. 2. If you see it before a
		variable, it says we want to follow the reference to what it's pointing to in memory. 3. Multiplication

2/6/2023
Stdout is where standard output goes to. fprintf lets the programmer dictate where the output is being pushed to.

Can cast parameters to void if you aren't using them to suppress unused parameter warnings

atoi - ascii to integer.
ascii - 8 bit char represented on a table. Must convert ascii to integer, that's what the atoi function does.
	converts ascii characters to integers.

Variables in the main function are different than variables in other functions even if they have the same name.

Can specify that you want variables to be pointers, and will then expect an address, and will require you to follow the
reference. Can use this to modify the values of variables in main from other functions, to get around the aformentioned
note about variables in the main function.

Specify type of pointer therefore able to associate the amount of bytes needed to allocate  to hold each type.
Can step through array individually and traverse via addresses if you KNOW that something is there.

Pointers almost equal arrays

All three of these are equivalent ways to access memory.
ip[3] == *(ip+3) == array[3];

2/8/2023
Registers - Memory, but not accessible memory. Only place where operations can take place. Registers are 64 bits in size. Instructions are stored
in executable files, and need to be able to run from registers.

gdb -tui --args [program] [arg1] [arg2]  - Lets you step through your program one operation at a time. Also what the lab assignment is on friday. -tui means text user interface
	Can add break points 'break line#'
	Use 'step' or 'next' to go through the program line by line with breakpoints.
	Step lets you go inside that function if loaded with -g
	Use 'print [variable]' to see what the program sees each variable as. Or add &[variable] to see address
	Use 'set' to set a variable to a different value mid-debugging
	$rdi shows whatever the register is at 1st. $rsi is second. Da first. The Second. Not able to access it, it's temporary. 16 fixed point
		registers. Number of other registers for float points. Advancements in chips increase the amount of transistors, therefore increasing
		the registers.
	Pass pointer whenever you want to manipulate the variable.
	Use 'watch [variable]' to get notified about change in variables.

	There's a proficiency test for gdb so learn it. It will be important. So definitely yeah.

Every time you need to go out into memory to find a value it's more inefficient in time, way more clock cycles.
Try to make access from memory go into dram and caches so they are more fast. Performance is gold.

2/13/2023

We can modify variables in the other function by passing in the address & and de referencing the variable * and changing that.
Just like creating ssh key pair you need to upload the key pair in gitlab as well.
(See switch4.c in labs)

'Which' is looking for executables

2/15/2023
Programs in Memory, Dynamic Memory Allocation, and Valgrind

In C you must allocate the memory.
What is the difference between static and dynamic memory allocation

Static is allocated before the program runs
Dynamic is allocated after the program runs
	Running a program and allocate space as new information is coming in
		Saves space

How do we allocate dynamically?

When we execute a program, working with the OS it loads portions of the executable file into memory
and create a virtual memory allocation/representation. 
	Usually around address 0x400000

Every program gets placed in its' own memory space.
When the program starts to execute through main, it has to go and get the bytes from memory that represents the instructions on the microprocessor.
	Must map from virtual to physical memory.

As we're going to call a function, information goes on the stack, either popped or ignored and builds it.
Text is the lowest address in the stack, top of the stack command line arguments is the highest address.

Stack is a data structure and behaves like so. 

C Program memory:
1. Text or code segment (program code, values used to initialize global and static variables)
2. Data segment in 2 parts (Initialized variables themselves, global static, and constant data and uninitialized data)

When program is loaded at execution time, the C runtime environment is created and the values of initialized variables from the code (text) segment are placed into respective actual addresses (in RAM)

Stack is a region of memory used for temporary variables.
	Local variables are automatically created on the stack
	Grows/shrinks as functions push and pop local variables
	Variables are allocated and freed automatically
	Limited in size
	Stack variables only exist while function/block is running
Heap is a large region of memory for all types of variables.
	Programmer eeds to allocate memory on the heap
	Programmer needs to free memory or else memory leaks
	Heap variables are global
	Need to use pointers.

If you're never de-allocating heap space you could eventually run out of memory.
	(Garbage collection)
	Valgrind is a tool that helps show garbage collection I think

Pro/Con List (Stack+Heap)

Stack:
	Fast access, don't have to explicitly deallocate free variables
	Space managed efficiency by CPU, memory won't become fragmented
	Local variables only
	Limit on stack size (OS dependent)
	Variables cannot be resized
		Could mess up addressesif supported
Heap:
	Variables can be accessed globally
	No limit on memory size (kinda)
	Relatively slower access
	No guaranteed efficient use of space, memory may become fragmented
	Programmer must manage memory (allocate/free variables)
	Variables can be resized
		Just need to go to different place with enough memory, make a deepcopy then 

Contiguous memory addresses are useful for time complexity and keeping pointer arithmetic correct

Memory needed is not know during compile time
Needed when a function returns a poitner to a structure created by the function

'man malloc'
Allocating Memory:
malloc - memory allocation
realloc - reallocation memory
free - free memory
sizeof - construct to return size of any object
calloc - clear (set to 0) memory allocation
#include <stdlib.h>

Prototype function:
	Contains name of function
	List of parameters
	Number/Types
	What the function is to return (else void)

size_t is used to identify the size of something in bytes, so it isn't confined by the amount of bytes allowed to allocate other data types.

malloc returns void because it's just a pointer, and allows you to typecast
We want to typecast so we know how many bytes we're pointing to. 

int *arraypointer = (int*malloc) 100;

If we want to free up memory that we already malloc'd free(*arraypointer);
calloc clear alloc, combines the operations of malloc and sets the space to 0.
When we're done programming something, we need to take responsibility to free that memory.

realloc() changes the size of memory block pointer to ptr to size bytes to a new location
	Unpredictable Performance
sizeof() returns the size of any object referred to.
Different mechanisms associated with the blocks of allocated memory. Through the memory manager, we can access that memory.

Fundamentally the same thing as just declaring allocation.
This dynamic allocation will persist and can be globally accessed, can be resized, can be dynamic, and such.

"Static" allocation of space is straightforward, with variables or arrays declared locally or globally
char myarray[1000];
char *ptr=NULL;
for (ptr=myarray; (ptr-myarray) < 1000; ptr++)
   // do something with each entry of myarray
Dynamic allocation asks the OS for space for the pointer to access
#include <stdlib.h>
char *myarray = NULL;
char *ptr = NULL;
myarray = (char *)malloc(1000);  // 1000 in bytes, can be a variable
for (ptr=myarray; (ptr-myarray) < 1000; ptr++)
   // do something with each entry of myarray

No check for if malloc fails.

(Implementation of malloc and memory allocation functions)
#include <stdio.h>
#include <stdlib.h>

int main() {
   char *str;

   /* Initial memory allocation */
   str = (char *)malloc(15);   /* 15 is # of bytes (works for char) */
   strcpy(str, "Dr.ErleTotally");
   fprintf(stdout, "String = %s,  Address = %u\n", str, str);

   /* Reallocating memory */
   str = (char *)realloc(str, 25);
   strcat(str, "Rocks!");
   fprintf(stdout, "String = %s,  Address = %u\n", str, str);

   free(str);
   return(0);
}

Unsafe functions in C could overrun space and go beyond and courrupting data that wasn't supposed to be changed.

C allows you to go to any pointer beyond what you allocated.

One byte more than the string length if you are copying a string
In general, you want the number of objects times the size of an object
So if we were allocating an array of ints, rather than 1-byte chars:
int *ip = (int *)malloc(1000 * sizeof(int));
sizeof is an operator that determines the size of the data type passed as the parameter
Note that just like an array, it is easy to have a pointer (or array index) exceed the allocated space (and cause problems)

2/20/2023 - Virtual Class

When facing development of a larger program, you need to organize how to manage how to develop in separate files.
Reused or organized so they can be used on other projects: top-down development.

Create 'skeleton' of the entire program and step into each function to see what you need to do.

Top-down development: Simple main function that calls other (initially abstract functions) and see how to implement functions so the whole program can be filed and simple testing can be performed.

Bottom-up development: Identify key low-level needs and building functions to provide the services, while also testing code to exercise functions and verify correctness.

Divide-and-conquer: Especially useful when coding in groups, might just share object files with each other (w/ documentation on how to use it)

Use combination of the three.

Modular approach. Know and test specific functions, and don't have to worry about getting the exact variables and functionality.
	Allows to test smaller functions more robust and can implement functionality.
	Debugging also can narrow down the development bugs in order to diagnose each problem.
If you can see the entire algorithm on one screen, it's better to develop in time. 

Can use combination of compiler options and 'make' command.
	man make !!!

Very good to use multiple source code files, saves time, reduces errors.

Can stop compiler before creating an executable, and that not-ready-to-execute binary file can be linked with similar files to create a larger, fully complete executable file.

Continue to use mg, but can do other stuff.

Compiler options of interest:
	-Wall
	-Wextra (can flag legitimate code)
	-Wwrite-strings
	-g inserts debug information into executable
	-c creates a relocatable object file (not executable)

Compiling is not a single step:
	preprocessing: processes include files, conditional compilation instructions, macros
	compilation: takes output of preprocessor and source code and generates assembler source code
		gcc -s produces .s file
	assembly: takes the assembler source code and produces an assembly listing with offsets stored in an object file
		gcc -c t produce .o file
	linking: takes one or more object files or libraries as input and combines them to produce a single executable file
	Use -save-temps to save all intermediate files


Relocatable object file (.o)
	Contains code and data in a form that can be combined with other relocatable object files to form an executable object file.
	Each .o file is produced from exactly one source (.c) file.

Executable object file (a.out)
	Contains code and data in a form that can be copied directly into memory and then executed

Shared object file (.so)
	Special type of relocatable object file that can be loaded into memory and linked dynamically at load or runtime.
	Dynamic Link Libraries by windows (DLL).

All object files have a standard binary format.
One unified format for .o, a.out, .so:
	ELF binaries (executable and linkable format)

gcc -save-temps "blah.c": Shows the different temp object files

Make utility and Makefiles
	With medium to large projects containing many files it's difficult to
		Type commands to compile all the files correctly each time
		Keep track of which files have been changed
		Keep track of files' dependencies on other files
	The make utility automates this process.

make is utility, makefile or Makefile contents.
target:prerequisite
	recipe	<-- must be preceded by tab

Target is file to be generated, usually an executable or object file, and can simply be named of recipe
Prerequisite is zero or more files used to create the target (dependencies)
Recipe is one or more system commands that create the target or achieve the desired result and can span lines.

Makefiles can compile specific changes something and makes its way through the hierarchy instead of the thing, and can compile the things more efficiently.

Forces the intermediate files to be deleted, and then running 'make clean' goes in the top level ones and removes the executable and all .o files
clean:
	rm -f *.o
	rm -f prog

Good programming practices as to do well on the programming projects:
Organization & Readability
	Code written in a modular fashion
	Variables are given meaningful names
	Consistent indentation used for blocks (besides curly braces who cares bout those)
	Functions should generally not exceed one screen, limited to specific purpose/calculation/allocation
	Use stevens-style wrapper functions to make system calls and embed error checking
	Comments are added to describe logic within a block of code.
	Assignment-specific requirements if any, were followed.

Robustness & Efficiency
	Error checking is done wherever possible
	Checking/handling of short counts is performed
	Check every function for failure codes (especially system calls)
	Keep variables' scopes as small as possible (narrow/limited)
	Initialize all variables especially pointers
	Functions created such that code blocks are not duplicated
	Fixed loop bounds are determined prior to entering loop
	Assignment-specific requirements are followed

Strongly consider top-down approach:
	Develop algorithm first (think)
	Create a simple main function with function calls and very little logic
	Create function shells
	Add logic to the function shells slowly and test as you go allocating
	Test thoroughly as notable changes come allocating
	Push changes to repo after each notable change

Defensive programming:
	Larger the project, the more difficult finding subtle errors becomes
	Code defensively by:
		Checking every funciton for failure codes (esp system calls)
		Keep variables' scopes as small and narrow as possible
		Initialize all variables, especially pointers
		Write testing harnesses for all functions
		Document carefully and describe all assumptions for values passed as parameters to your functions
		Verify parameters are valid before you use them
		Use assert liberally to enforce those assumptions

2/22/2023 - Small slide deck for some reason

Position ourselves to learn ourselves. Taught to teach ourselves, and need to learn from ourselves and our resources.
Type out what we need to do. Think before we code, top-down approach.
Start things earlier, begin processing, and read through multiple times.

"It's not that they don't care, but you're always under a time constraing. Decide what you can and cannot get to."

Using make files to pull in and stuff maybe next.
It's not about the money, it's about the message.

System call
Executing instance of a program.
By default all programs execute in user mode.
In order to interact with file system or other restsricted systems or functionalities, a C program must invoke a system call
	A system call can be devined as a request to the operating system to do something on bejalf of the program.
	During execution of a system call, the mode is changed from user mode to kernel mode (aka system mode)
The kernal is the core of the OS program and has control over everything; which is why all other software has to make requests of the OS/Kernel (like to create new processes and manage i/o)

'sleep n' command pauses command for a certain number of seconds.

Can interact with other systems. Ex. cd /proc 
'getenv' reads the user's environment space. Accessing information regarding the user, so it's not really a system call.

System call examples:
creat( ), open( ), close( ) – managing I/O channels
read( ), write( ) – handling input and output operations
lseek( ) – for random access of files
link( ), unlink( ) – aliasing and removing files
stat( ) – getting file status
access( ), chmod( ), chown( ) – for access control
exec( ), fork( ), wait( ), exit( ) – for process control
getuid( ) – for process ownership
getpid( ) – for process ID
signal( ) , kill( ), alarm( ) – for process control
chdir( ) – for changing working directory
mmap(), shmget(), mprotect(), mlock() – manipulate low level memory attributes
time(), gettimer(), settimer(),settimeofday(), alarm() – time management functions
pipe( ) – for creating inter-process communication 

Mentioned about being 'vertically conservative'
	See your whole function on one screen 
	Apply modular programming techniques
	
Wrap system calls.
	Might get error codes.
	Check return value from calls.

With system calls, you should always check the return values.
Error handling.
Save space by using "stevens-style wrapping"
	Only one line of code for system calls, rather than a bunch of them.
	Create a new function, call it the same as your old system call function, but differentiate with a capital letter.

in wrappers.h:

void *Malloc(size_t, size); //declaration, no definition no description, just declaring that the wrapped function exists.

in wrappers.c:

void *Malloc(size_t size){ //actually have the functionality in here
	void *ptr = NULL; //or 0
	if((ptr = malloc(size)) == NULL){ //can put our check in the line
		//must have an error, error handling goes here
		//Print some message and exit with nonzero return code
		//Unique message strerror(errno) shows the string error for error number.
		fprintf(stderr, "Could not allocate space for %ld bytes - %s", size, strerror(errno));
	}
	//Must be non error condition
	return ptr;
}

For program convention in linux, return 0 if things are right, nonzero if things are incorrect
We can have different reasons on why the program fails, if we return 0 when fails, there's no way to distinguish what error occured.

stdout is the default standard out.
stdin is the same terminal/console that you write the program in.
stderr is the standard error stream, could be something different.

2/27/2023
makefile is control file to identify dependencies and recipies in order to create one or more outputs or targets.

When working with modular files, header or source code incorporations doesn't need to worry about what may have changed and automatically 
	calls appropriate recipies in order to construct the program.

Other tools to do the same compilation, but make is a good intro to "dependency management" in the Linux OS

Access struggle:
	Wouldn't let you use the access command in the .h file.
	Look at return codes, not error if file given. Wants to process but know it isn't an executable.

System calls: functionality that our user process does not have access to directly, interacting with the OS to find that functionality.

Equally valid for code writing for error checking and handling in one file source code. 

Assume nonzero non null pointer, pass that and assume that free works correctly

Incude-guard. Guards against the process including something more than one time.

sizeof.c 

