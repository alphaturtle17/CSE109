1/30/2023 Grading and compiling on the sunlab, so use it to program as well.

PATH: searches inorder for commands We changed PATH in HW0 to make the current directory something that we search while compiling BASH: 
bourne again shell, language we remote into the sunlab

'man' command: manual pages to read different manuals for code.

'mg -o program program.c': compiles c programs with all the warnings and other stuff you want, creates the executable file as the name you 
	provide rather than a.out


Why C? Weakly-typed: Can read data from memory as any type you like Flexible, puts the decision in the programmer's hand's Staticly-typed: 
	Types are only checked at compile time Structured: Structures used to control the flow of execution Procedural: Series of well 
	structured steps, systematic order of statements, functions, and commands. Lower level: Can directly access structures that are 
	tied to hardware. Minimal: No ops to directly deal with strings, lists, or arrays. No help.

C was created to be simple, flexible, and to trust the programmer. Provides only one way to do each operation. Fast, not necessarily 
portable. C is at the top of benchmark times. C is used in Microsoft Windows, Linux, Mac, and Mobile

'#' octothorpe loads files '#include <stdio.h>' loads header file


2/1/2023 Introducing arguments and pointers

Typical declaration for main is: int main(int argc, char *argv[]){} argc, argv are arguments (arg count arg values respectively) argv is 
	an array of pointers.
The very first entry in argv[] (argv[0]) is a pointer to the name of the program that was executed. ALWAYS

A pointer is an address in memory. Can have a variable that contains the address to something. int x; //x is an integer variable int *xp = 
	&x; //*xp is a pointer to type int whose initial value is equal to the address of x

Segment violation: going to areas in memory that isn't allowed results in that Hard link: Multiple names for the same file.

Has an array of addresses that point to the start of each string. Array of pointers.

Segmentation violation: Program tried to access an area of memory tht isn't allowed to access

Use double quotes to bypass whitespace as automatic displacement.

Do we need a null integer before you access a memory. Fixlengthed data types need null terminator.

'chmod': to change permissions

64 bit addressable machines are 8 bytes.
Not passing the array, pasing out the reference to the cell of the array.

'int *ip = &array[3];' asterisk is a pointer, all addresses are 8 bytes. Doesn't matter what it points to, regardless any address on a 64 bit
	machine is 8 bytes.
'&': ampersand symbol: Looks for the address of something. Ampersand A mpersand. Address. Printing out the address of
		       variable.
'*': pointer: Points to something, used three ways. 1. Denotes a variable as a pointer. 2. If you see it before a
		variable, it says we want to follow the reference to what it's pointing to in memory. 3. Multiplication

2/6/2023
Stdout is where standard output goes to. fprintf lets the programmer dictate where the output is being pushed to.

Can cast parameters to void if you aren't using them to suppress unused parameter warnings

atoi - ascii to integer.
ascii - 8 bit char represented on a table. Must convert ascii to integer, that's what the atoi function does.
	converts ascii characters to integers.

Variables in the main function are different than variables in other functions even if they have the same name.

Can specify that you want variables to be pointers, and will then expect an address, and will require you to follow the
reference. Can use this to modify the values of variables in main from other functions, to get around the aformentioned
note about variables in the main function.

Specify type of pointer therefore able to associate the amount of bytes needed to allocate  to hold each type.
Can step through array individually and traverse via addresses if you KNOW that something is there.

Pointers almost equal arrays

All three of these are equivalent ways to access memory.
ip[3] == *(ip+3) == array[3];

2/8/2023
Registers - Memory, but not accessible memory. Only place where operations can take place. Registers are 64 bits in size. Instructions are stored
in executable files, and need to be able to run from registers.

gdb -tui --args [program] [arg1] [arg2]  - Lets you step through your program one operation at a time. Also what the lab assignment is on friday. -tui means text user interface
	Can add break points 'break line#'
	Use 'step' or 'next' to go through the program line by line with breakpoints.
	Step lets you go inside that function if loaded with -g
	Use 'print [variable]' to see what the program sees each variable as. Or add &[variable] to see address
	Use 'set' to set a variable to a different value mid-debugging
	$rdi shows whatever the register is at 1st. $rsi is second. Da first. The Second. Not able to access it, it's temporary. 16 fixed point
		registers. Number of other registers for float points. Advancements in chips increase the amount of transistors, therefore increasing
		the registers.
	Pass pointer whenever you want to manipulate the variable.
	Use 'watch [variable]' to get notified about change in variables.

	There's a proficiency test for gdb so learn it. It will be important. So definitely yeah.

Every time you need to go out into memory to find a value it's more inefficient in time, way more clock cycles.
Try to make access from memory go into dram and caches so they are more fast. Performance is gold.

2/13/2023

We can modify variables in the other function by passing in the address & and de referencing the variable * and changing that.
Just like creating ssh key pair you need to upload the key pair in gitlab as well.
(See switch4.c in labs)

'Which' is looking for executables

2/15/2023
Programs in Memory, Dynamic Memory Allocation, and Valgrind

In C you must allocate the memory.
What is the difference between static and dynamic memory allocation

Static is allocated before the program runs
Dynamic is allocated after the program runs
	Running a program and allocate space as new information is coming in
		Saves space

How do we allocate dynamically?

When we execute a program, working with the OS it loads portions of the executable file into memory
and create a virtual memory allocation/representation. 
	Usually around address 0x400000

Every program gets placed in its' own memory space.
When the program starts to execute through main, it has to go and get the bytes from memory that represents the instructions on the microprocessor.
	Must map from virtual to physical memory.

As we're going to call a function, information goes on the stack, either popped or ignored and builds it.
Text is the lowest address in the stack, top of the stack command line arguments is the highest address.

Stack is a data structure and behaves like so. 

C Program memory:
1. Text or code segment (program code, values used to initialize global and static variables)
2. Data segment in 2 parts (Initialized variables themselves, global static, and constant data and uninitialized data)

When program is loaded at execution time, the C runtime environment is created and the values of initialized variables from the code (text) segment are placed into respective actual addresses (in RAM)

Stack is a region of memory used for temporary variables.
	Local variables are automatically created on the stack
	Grows/shrinks as functions push and pop local variables
	Variables are allocated and freed automatically
	Limited in size
	Stack variables only exist while function/block is running
Heap is a large region of memory for all types of variables.
	Programmer eeds to allocate memory on the heap
	Programmer needs to free memory or else memory leaks
	Heap variables are global
	Need to use pointers.

If you're never de-allocating heap space you could eventually run out of memory.
	(Garbage collection)
	Valgrind is a tool that helps show garbage collection I think

Pro/Con List (Stack+Heap)

Stack:
	Fast access, don't have to explicitly deallocate free variables
	Space managed efficiency by CPU, memory won't become fragmented
	Local variables only
	Limit on stack size (OS dependent)
	Variables cannot be resized
		Could mess up addressesif supported
Heap:
	Variables can be accessed globally
	No limit on memory size (kinda)
	Relatively slower access
	No guaranteed efficient use of space, memory may become fragmented
	Programmer must manage memory (allocate/free variables)
	Variables can be resized
		Just need to go to different place with enough memory, make a deepcopy then 

Contiguous memory addresses are useful for time complexity and keeping pointer arithmetic correct

Memory needed is not know during compile time
Needed when a function returns a poitner to a structure created by the function

'man malloc'
Allocating Memory:
malloc - memory allocation
realloc - reallocation memory
free - free memory
sizeof - construct to return size of any object
calloc - clear (set to 0) memory allocation
#include <stdlib.h>

Prototype function:
	Contains name of function
	List of parameters
	Number/Types
	What the function is to return (else void)

size_t is used to identify the size of something in bytes, so it isn't confined by the amount of bytes allowed to allocate other data types.

malloc returns void because it's just a pointer, and allows you to typecast
We want to typecast so we know how many bytes we're pointing to. 

int *arraypointer = (int*malloc) 100;

If we want to free up memory that we already malloc'd free(*arraypointer);
calloc clear alloc, combines the operations of malloc and sets the space to 0.
When we're done programming something, we need to take responsibility to free that memory.

realloc() changes the size of memory block pointer to ptr to size bytes to a new location
	Unpredictable Performance
sizeof() returns the size of any object referred to.
Different mechanisms associated with the blocks of allocated memory. Through the memory manager, we can access that memory.

Fundamentally the same thing as just declaring allocation.
This dynamic allocation will persist and can be globally accessed, can be resized, can be dynamic, and such.

"Static" allocation of space is straightforward, with variables or arrays declared locally or globally
char myarray[1000];
char *ptr=NULL;
for (ptr=myarray; (ptr-myarray) < 1000; ptr++)
   // do something with each entry of myarray
Dynamic allocation asks the OS for space for the pointer to access
#include <stdlib.h>
char *myarray = NULL;
char *ptr = NULL;
myarray = (char *)malloc(1000);  // 1000 in bytes, can be a variable
for (ptr=myarray; (ptr-myarray) < 1000; ptr++)
   // do something with each entry of myarray

No check for if malloc fails.

(Implementation of malloc and memory allocation functions)
#include <stdio.h>
#include <stdlib.h>

int main() {
   char *str;

   /* Initial memory allocation */
   str = (char *)malloc(15);   /* 15 is # of bytes (works for char) */
   strcpy(str, "Dr.ErleTotally");
   fprintf(stdout, "String = %s,  Address = %u\n", str, str);

   /* Reallocating memory */
   str = (char *)realloc(str, 25);
   strcat(str, "Rocks!");
   fprintf(stdout, "String = %s,  Address = %u\n", str, str);

   free(str);
   return(0);
}

Unsafe functions in C could overrun space and go beyond and courrupting data that wasn't supposed to be changed.

C allows you to go to any pointer beyond what you allocated.

One byte more than the string length if you are copying a string
In general, you want the number of objects times the size of an object
So if we were allocating an array of ints, rather than 1-byte chars:
int *ip = (int *)malloc(1000 * sizeof(int));
sizeof is an operator that determines the size of the data type passed as the parameter
Note that just like an array, it is easy to have a pointer (or array index) exceed the allocated space (and cause problems)

